# Tigger
## 活性分析
以语句为基本块进行自下而上的活性分析
## 寄存器分配
使用图着色算法进行寄存器分配.\
利用活性分析的结果构造冲突图,兼用邻接表和邻接矩阵表示冲突图.\
图染色有四种操作:\
1.简化 对于度数小于k的传送无关的点,将其从图中删除并放入栈中.\
2.合并 对于一条传送指令,对其关联的两个点在保守规则下合并.\
3.冻结 冻结一条传送指令,将他当作非传送指令.\
4.溢出 将图中度数最大的点放入栈中,并从图中删除..\
操作按1.2.3.4的优先级进行,直到图中不再有点.\
将栈中元素依次弹出,并为其分配颜色,如果无颜色可用,则将该顶点真实溢出.\
若有真实溢出发生,则重写程序,为溢出的变量分配栈空间,加入load语句和store语句来读取和写回,并创建临时变量进行运算.
## 其他说明
Tigger不再创建符号表,因为其中所有变量名称的作用域都是全局,所以直接由词法分析器为其分配一个id(>27).\
全局变量和栈数组不分配寄存器,直接存到内存中.
## 预着色节点的处理
Tigger有28个寄存器,给其确定id为0-27,并为其预着色\
函数参数及返回值需要预着色.
进入函数体时创建变量保存参数,因此形参使用寄存器会视情况而定,不会长期占用a0-a7\
每次进入函数体时保存被调用者保存的寄存器,return时恢复.\
每次调用call时保存调用者保存的寄存器以及a0-a7中不用做参数的部分,call后恢复.\
事实上由于寄存器分配时会合并部分传送指令,因此最后生成的程序正常情况下不会有大量预着色节点的move指令.\

合并预着色点相关传送节点的例子

MiniC代码
```
int v0;
v0 = getint();
int v1;
v1 = func(v0);
int v2;
v2 = putint(v1);
return v2;
```
tigger代码
```
call getint
call func
call putint
return
```
变量大量合并,只用了a0,没有一条move指令.
