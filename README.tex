\documentclass[UTF8]{article}
\usepackage{ctex}
\usepackage{enumerate}[i]
\usepackage{listings}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{geometry}
	\usepackage{fontspec}
	\setmonofont{Consolas}
\usepackage{xcolor}
\lstset{
    columns=fixed,    
    basicstyle=\ttfamily\scriptsize,   
    numberstyle=\tiny,
    numbers=left,                                        % 在左侧显示行号
    frame=none,                                          % 不显示背景边框
    backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
    keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
    numberstyle=\footnotesize\color{darkgray},           % 设定行号格式
    commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
    stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
    showstringspaces=false,                              % 不显示字符串中的空格
    language=c++,                                        % 设置语言
}
\begin{document}
\title{编译实习MiniC报告}
\author{罗昊\quad 1700010686}
\maketitle
hcc(Hao miniC Compiler) is a simple compiler for MiniC.

It contains 2 parts: eeyore and tigger. 

eeyore convert MiniC code to Eeyore code (a kind of three-address code)

tigger convert eeyore code to Tigger code || Riscv64 asm || Riscv32 asm.

Get source code from https://github.com/vangohao/hcc

to build the project, run ``make'' in the hcc directory.

to run the hcc compiler, run ``./hcc qsort.c'' or ``./hcc qsort'' to compile qsort.c to qsort.s

use ``-m32'' option to get Riscv-32 code (default is Riscv-64)

\section{supported additional C rules besides MiniC}
\begin{enumerate}
\item 支持空语句( ; )
\item 支持逻辑表达式与算术表达式互相自动转换.
\item 支持无返回值调用函数.
\item 支持调用函数时使用表达式作为参数.
\item 支持在程序体内声明函数.
\item 支持C风格多行注释和C++风格单行注释.
\end{enumerate}
\section{error report}
\begin{enumerate}
\item 报告语法错误和词法错误及其行号,并给出该处正确的token类型提示.
\item 检查标识符使用,如果使用了未定义的标识符会报错.
\item 检查标识符重复,对于重复定义的报错,函数名与变量名冲突的报错,如果在\{\}程序块内使用与程序块外同名的变量,则不会报错.
\item 检查函数参数表,对于重复声明但参数表不一致,或定义与声明参数表不一致,或调用时所用的参数表与声明的类型不一致时报错.
\item 检查+,-,*,/,\%运算符对于数组类型变量的不合法操作给出错误提示,这些操作中除了 (int[])+(int), (int)+(int[]), (int[])-(int), 外涉及数组的运算都是不合法 的.
\item 检查对数组变量的赋值,无法将数值赋给数组变量.
\item 检查a[b]使用,如果a不是数组变量,会报错.
\end{enumerate}
\section{warning report}
\begin{enumerate}
\item 控制流到达函数结尾(Control reaches end of function)
\end{enumerate}
\section{Eeyore}
\subsection{简介}
\begin{enumerate}
\item 使用flex,bison和C++构建,将输入的MiniC代码转换为Eeyore三地址代码.
\item 使用STL的map模板制作符号表,使用链表串联内外层程序块的符号表.
\item 使用回填法构建eeyore中的标号及goto语句.
\end{enumerate}
\subsection{代码结构}
代码由 symbol.cpp/h node.cpp/h gotolist.cpp/h fault.cpp/h main.cpp parser.y lexer.l构成
\begin{enumerate}
\item symbol.cpp/h 包含两个类的定义:
\begin{enumerate}[(1)]
\item Symbol 类,即符号类,每个Symbol对象对应一个符号(包括函数,常数,原生变量和临时变量)
\item SymbolTable 类,即符号表.
\end{enumerate}
\item node.cpp/h 包含两个类的定义:
\begin{enumerate}[(1)]
\item Node类,即语法树节点.
\item Label类,goto语句后面的标识(对于非M语句)或标号(对于M语句) ,用于建立跳转关系
\end{enumerate}
\item gotolist.cpp/h 包含Gotolist类的定义,gotolist就是跳转表,用于建立跳转关系.
\item fault.cpp/h 包含用于报错的函数.
\item main.cpp 主程序
\item parser.y 语法分析器,进行语法制导翻译.
\item lexer.l 词法分析器,进行词法分析并传递token及其基本属性给语法分析器
\end{enumerate}'
\subsection{BNF}
下面给出删除了所有处理语句的parser.y代码
\begin{lstlisting}
%code requires{
    typedef struct{
        int number;
        char* name;
        SymbolType type;
        Node* node;
    } foryystype;
    #define YYSTYPE foryystype
}
%{
    #define YYERROR_VERBOSE 1
%}


%token EQUAL NOTEQUAL LAND LOR T_INT MAIN IF ELSE WHILE RETURN IllegalCharacter
%token<number> INTEGER
%token<name> IDENTIFIER
%type<node> Goal BeforeMainStatement VarDefn VarDecls VarDecl FuncDefn FuncCreateIdTable Ifhead
%type<node> InsideFuncStatements FuncDecl MainFunc Statements Statement Expression Params Identifier
%type<node> M N
%type<type> Type
%right '='
%left LOR
%left LAND
%left EQUAL NOTEQUAL
%left '<' '>'
%left '+' '-'
%left '*' '/' '%'
%right NEGA '!'
%right '[' 

%%
Goal: BeforeMain MainFunc          
;
BeforeMain: BeforeMain BeforeMainStatement
|   %empty
;
BeforeMainStatement: VarDefn | FuncDefn | FuncDecl | ';'
;
VarDefn: Type Identifier ';'    
| Type Identifier'['INTEGER']' ';' 
;
VarDecls:VarDecls ',' VarDecl  
| VarDecl                      
| %empty                      
;
VarDecl: Type Identifier      
| Type Identifier '[' INTEGER ']'
| Type Identifier '[' ']'          
;
FuncCreateIdTable: Type Identifier '(' 
;
FuncDefn: FuncCreateIdTable VarDecls ')' 
'{'    
InsideFuncStatements M
'}'  
;
InsideFuncStatements: InsideFuncStatements M FuncDecl        
| InsideFuncStatements M Statement                          
| FuncDecl                     
| Statement                    
;
FuncDecl: FuncCreateIdTable VarDecls ')' ';'
;
MainFunc: T_INT MAIN '(' ')'           
 '{' InsideFuncStatements M'}'         
;
Type: T_INT  
;
Statements: Statements M Statement     
| Statement
;
M: %empty
;
N: %empty 
}
;
Ifhead:  IF '('  Expression ')'  
;
Statement: '{' Statements '}'       
| ';'          
| Ifhead M Statement 
| Ifhead M Statement N ELSE M Statement  
| WHILE M '(' Expression ')'  M Statement 
| Identifier '=' Expression ';' 
| Identifier '[' Expression ']' '='  Expression ';' 
| Identifier '(' Params ')' ';' 
| VarDefn
| RETURN Expression ';'         
| error ';'                     
;
Expression:  Expression '+' Expression 
| Expression '-' Expression            
| Expression '*' Expression            
| Expression '/' Expression            
| Expression '%' Expression           
| Expression '<' Expression           
| Expression '>' Expression           
| Expression EQUAL Expression       
| Expression NOTEQUAL Expression  
| Expression LAND M Expression       
| Expression LOR  M Expression  
| Expression '[' Expression ']' 
| INTEGER                       
| Identifier                    
| '!' Expression                
| '-' Expression %prec NEGA     
| Identifier '(' Params ')'     
| '(' Expression ')'            
;
Params: Params ',' Expression
| Expression               
| %empty   
;
Identifier: IDENTIFIER          

%%
\end{lstlisting}
对以上BNF的说明:
\begin{enumerate}[(1)]
\item 使用bison编译时会报一个Shift/reduce冲突,这是因为If和IfElse有所冲突, 但由于Bison的规则是冲突时优先选择移入, 所以在保留此冲突的情况下编译的语法分析器仍然是正确的.例如下面这段代码:
\begin{lstlisting}
if (x < 5)   if (x<3)  y = 1; else y = 2; 
\end{lstlisting}
其中的else 应该与第二个if 构成 IfElse, 而第一个if 是单独的If, 没有Else 与其配对.

所以,对于 x == 4 运行结果应该是 y = 2;
\item FuncCreateIdTabel 非终结符是FuncDefn和FuncDecl的公共部分, 由于程序需要在这部分之后首先为函数创建符号, 所以需要加上控制代码, 为了避免冲突, 所以将这部分单独拿出来加上控制代码; 类似的, Ifhead非终结符对if的条件表达式先做处理, 为了避免冲突, 所以将这部分单独拿出来加上控制代码.
\item 对M 和 N 的说明: M和N是用于流程控制的占位符,其中M将成为语句标号. 本MiniC转Eeyore编译器使用回填法$^{[1]}$处理while语句,if语句以及逻辑运算符涉及的条件跳转. 具体作用后面会讲.
\end{enumerate}
\subsection{类结构}
\includegraphics[width=\linewidth]{uml_eeyore} 
下面简要介绍一下以上几个类的组成和作用
\subsubsection{Symbol 类}
Symbol类是符号类.

符号的类型定义在enum SymbolType中:
\begin{lstlisting}
enum SymbolType //符号类型
{
    Int=0,          //整形变量
    IntPtr=1,       //整形数组
    FunPtr=2,       //函数
    Immediate=3,    //直接数
    Logic=4,        //逻辑表达式
    Error=5,        
};
\end{lstlisting}
符号类主要功能是处理表达式运算和函数调用
\begin{enumerate}[(1)]
\item 两个静态方法ProcessDualOp和ProcessSingleOp传入两个Node* 类型节点,返回一个Symbol指针,指向运算所得的临时变量, eeyore在翻译每个运算时都会创建一个临时变量, 将运算结果赋给临时变量.
\item Declear方法配合decleared属性, 由于parser第一次遇到一个令牌IDENTIFIER并不是在VarDefn非终结符中,而是在identifier终结符中, 因此在此时就会将新遇到的符号插入当前符号表top中, 而在VarDefn中,调用Declear方法将decleared属性设为true. 在Expression中遇到相应符号时, 需要检查符号的decleared属性,必须是true,否则会报错. 对于函数,Declear方法会存入参数表.
\item Define方法,适用于函数, 作用是声明函数已定义, 若此函数已被声明, 则还需检查此处传入的参数表是否与声明时使用的参数表相匹配,若不匹配则会报错. 但函数声明和定义都不是调用的必要条件, 没有声明的函数也可以直接调用, 但已经声明或定义的函数在调用时会通过checkParams方法检查参数表是否匹配.
\item CallWithParams方法,parser在遇到函数调用语句时调用, 作用是按照函数的声明或定义状态检查参数表并给出相应的报错.
\item checkParams方法,这是个private方法,作用是检查传入的参数表是否与paramList相匹配. 参数表的类型是Node* ,也就是VarDecl对应的语法树节点. 检查的方法是遍历链表, 检查节点的sym属性的type属性是否对应或可以隐式转换,不匹配的给出错误提示.
\end{enumerate}

\subsubsection{SymbolTable类}
SymbolTable类是符号表, 有两个属性,分别是std::map<std::string,Symbol*>类型的table表和SymbolTable* 类型的prev, 指向上一个符号表, 所以SymbolTable实际是一个链式栈.

下面介绍SymbolTable支持的主要方法
\begin{enumerate}[(1)]
\item put方法,参数为一个字符串和一个Symbol指针, 作用是将该符号插入符号表.
\item get方法, 参数是一个字符串,返回值是一个Symbol指针, 将首先在当前符号表中查找该符号, 如果没有, 则调用prev即上一级符号表的该方法, 如果整个符号表中都找不到该符号,则返回null
\item gethere方法,在当前符号表中查找该符号, 如果没有就返回null, 不会递归查找上一级符号表.
\end{enumerate}

\subsubsection{Node类} 
Node类是语法树的节点类,实质是一个结构体,没有实质性的方法.

Node节点的种类用enum NodeType
类型定义如下:
\begin{lstlisting}
enum NodeType //语法树节点所对应语句类型
{
ExprArith=0,            //数值表达式
ExprLogic=1,            //逻辑表达式
Assign=2,               //赋值语句
If=5,                   //If语句
IfElse=6,               //IfElse语句
While=7,                //While语句
Return=9,               //Return语句
Vardfn=10,              //变量定义语句
Fundcl=11,              //函数声明语句
Fundfn=12,              //函数定义语句
MainFun=13,             //main函数
ArrayAssign=14,         //数组赋值语句
Symbol1 = 15,           //未定类型的临时符号
Params=16,              //参数表(调用时)
Funcall=18,             //函数调用语句
VarDcl = 20,            //参数表(定义或声明时)
Empty = 21,             //空类型
Stmts = 22,             //程序体
};
\end{lstlisting}

Node类包含的属性如下:
\begin{enumerate}[(1)]
\item left, right Node指针, 指向左子节点和右子节点
\item type, NodeType类型, 节点类型.
\item val int类型, 用于储存属性值,例如函数节点的参数个数, Params节点的当前参数个数等,此外,在identifier中, 该属性还指示该符号是在最顶层符号表中找到的还是上级符号表中找到的, 以便后续必要时进行覆盖定义. 该属性为综合属性.
\item line int类型, 储存该节点在源文件中的代码行号
\item instr Label类型,goto语句后面的标识(对于非M语句)或标号(对于M语句) ,用于跳转
\item nextlist, truelist, falselist, 是Gotolist类型指针,实际是跳转表, 分别储存跳转到当前语句结尾、当前语句为真位置、当前语句为假位置的goto指令,用于回填。该属性为综合属性.
\item sym 是Symbol指针类型,保存当前节点对应的符号.
\end{enumerate}
\subsubsection{Label类}
Label类是goto语句后面的标识(对于非M语句)或标号(对于M语句) .属性如下:
\begin{enumerate}[(1)]
\item int类型id是标号的编号(对于M语句), 对于其他语句则为-1
\item static int 类型usedCount是Label的计数, 用于编号.
\item int类型 location是该goto语句或标号在生成代码序列中的编号, 用于回填
\end{enumerate}
下面是方法
\begin{enumerate}[(1)]
\item Init(int) 方法, 初始化当前Label, 传入的参数为location
\item Patch() 方法, 只有标号会调用, 作用是在生成的代码序列中补充显示该标号.
\end{enumerate}
\subsubsection{Gotolist类}
属性只有一个,是std::list<int>,储存的是goto语句在生成代码序列中的编号.

方法如下:
\begin{enumerate}
\item Gotolist(int) 初始化, 构造函数, 使list属性初始化为一个值的列表
\item merge(Gotolist\&) 返回值是Gotolist, 用于合并两个Gotolist
\item backpatch(Label* l) 这个函数非常重要, 用于回填, 作用是对于list中的每个元素i,对于其每个元素调用全局函数Output::patch(int i,Label \& l); 对于非空的list, 一并调用l的Patch()函数显示标号.
\end{enumerate}
\subsection{对于回填法和逻辑运算的说明}
回填法用于解决语法制导翻译过程中生成的goto语句跳转到的编号不确定的问题.$^[1]$

下面分几个部分说明:
\begin{enumerate}[(1)]
\item M占位符的作用: 

M占位符是标号位置, 翻译到M占位符时会在该位置初始化一个标号.
\item N占位符的作用:

N占位符是goto语句, 翻译到N占位符时会将该Node的instr属性初始化为一个goto语句,也就是说,该处必有跳转.这只用于含有else的if语句,因为执行完true的代码块以后必须跳过后面的else代码块;
\item Gotolist 的作用, 每个逻辑表达式都有他的nextlist, truelist和falselist(实质是综合属性);  分别对应于一个标号(也即M占位符), 内容是这三个标号对应的goto语句的集合(在生成代码序列中的编号)

\item 对于比较运算符,对其生成eeyore中的if语句, 并初始化两个goto语句对应true和false, 初始化truelist和falselist包含分别包含对应的goto语句, 对于比较运算符表达式, nextlist为空.

\item 对于逻辑运算符(包括与,或,非), 对应的调用merge函数由子节点的三个list计算出父节点的三个list. 很显然,这一步过程同时能够完成所谓的短路现象.

\item 对于回填过程 整个If,IfElse或While程序块处理完后即可进行调用三个gotolist的backpatch函数进行回填操作, 该函数调用全局函数Output::patch(int i, Label \& l);  这个全局函数找到生成代码序列中的第i项(必然以goto结尾), 在其后添加上跳转到的标号 l, 即完成了标号回填的过程.
\end{enumerate}
\subsection{对于逻辑表达式和算术表达式互相转化的说明}
本编译器将比较表达式以及或与非表达式视为逻辑表达式, 五则运算表达式视为算术表达式, 支持逻辑表达式和算术表达式的自动转化.

\begin{enumerate}[(1)]
\item 逻辑表达式转算术表达式: 生成一个临时变量x表示结果,将逻辑表达式的truelist指向运行x=1,然后跳过后面一句x=0;将逻辑表达式的falselist指向运行x=0.
\item 算术表达式转逻辑表达式: 设算数表达式对应的符号为x, 则将该语句翻译为和逻辑比较表达式x==0相同的翻译结果. 即为其生成if-goto-goto语句, 并将truelist初始化为第一个goto对应的序号, 将falselist初始化为第二个goto对应的序号.
\end{enumerate}
\section{Tigger}
\subsection{代码结构}
代码由analyz.cpp/h lexer.l tigger.y tigger.cpp/h main.cpp 构成

analyz.cpp: 包含三个类的定义: 

	1.Expression类,每个Expression对象对应一条Tigger/RiscV指令;
	
	2.Func类,每个Func对象对应一个函数; 
	
	3.Analyz类,单例类,负责整体处理工作以及函数间优化工作. 

analyz.h: 包含上述三个类的声明.

lexer.l: 词法分析器,负责词法分析,其中对于变量,区分全局变量,局部变量和形参,使用Analyz中的vcount属性
为变量分配id,并包含在yylval中.

tigger.y: 语法分析器,负责语法分析,负责将Eeyore语句转换为Expression对象, 以及负责Func类对象创建, Func类对象负责tigger的主要函数体内工作.

tigger.cpp: 包含一些公共函数.

tigger.h: 公共头文件.

main.cpp: 主程序函数和少量全局变量.
\subsection{类结构}
\includegraphics[width=0.7\linewidth]{uml} 

\subsubsection{Expression类}
\begin{lstlisting}
class Expression
{
public:
    ExprType type;          //类型
    bool isMove;            //是否为传送指令
    bool dead;              //是否为死代码
    bool visited;           //是否被访问过(用于活性分析)
    vector<int> left;       //左值变量
    vector<int> right;      //右值变量
    vector<int> imm;        //直接数
    vector<int> use;        //使用的变量集合
    vector<int> def;        //定义的变量集合
    set<int> in;            //入口活跃集合
    set<int> out;           //出口活跃集合
    list<Expression*> nexts;//下一条指令集合
    list<Expression*> prevs;//上一条指令集合
    map<int,int> constant;  //常数变量表,用于常数传播
    string funtocall;       //仅用于call语句
     //构造函数,用于创建Expression并自动将指针加入当前所在函数的exprs表
    Expression(ExprType _type,vector<int> _left,
    vector<int> _right,vector<int> _imm,
    string _funtocall="",bool push=true);
};
\end{lstlisting}
\subsubsection{Func类}
\begin{lstlisting}
class Func
{
public:
    Func(int _paramCount,string _name); //构造函数
    void Processor();                   //主函数
    int insert(int s,int v);            //向栈空间添加变量,s为大小,
                                        //v为变量id,返回值为栈上的编号
    void ReturnFunc(int v,int t);       //处理Return语句,v为变量id或常数值,
                                        //t为选项(0表示常数,1表示变量)
    void CallParam(int v,int t);        //处理Param语句,v和t的含义同上
    void CallFunc(int v,string f);      //处理call语句,v为存返回值变量,f为函数名称
    int getParamVar(int r);             //获取形参对应的局部变量编号
    friend class Expression;            //将Expression声明为友元
private:
    int paramCount;                     //参数数量
    int paramToCallWithCount;           //调用参数计数器
    int frameSize;                      //栈空间大小(不含保存调用者保存寄存器的临时空间)
    int frameMaxSize;                   //栈空间大小
    unordered_map<int,int> frameSaveTable;  //记录被调用者保存寄存器的保存位置
    unordered_map<int,int> frameArrayTable; //从栈上数组变量id映射到栈上位置
    string name;                        //函数名称
    vector<int> offset;                 //栈上数据位置
    vector<int> size;                   //栈上数据大小
    vector<int> paramTable;             //形参对应局部变量表
    list<Expression*> exprs;            //语句表
    vector<int> spilledVariableFrameMap; //由变量id映射到上面的offset和size数组的下标


    //Color Algorithm图染色算法
    static int colorNumber;             //颜色数
    list<int> initial;                  //待初始化的节点表
    list<int> simplifyWorklist;         //低度数传送无关节点表
    list<int> freezeWorklist;           //低度数传送相关节点表
    list<int> spillWorklist;            //高度数节点表
    list<int> spilledNodes;             //溢出节点
    list<int> coalescedNodes;           //已合并节点
    list<int> coloredNodes;             //已染色节点
    list<int> selectStack;              //栈
    list<Expression*> coalescedMoves;   //已合并传送指令
    list<Expression*> constrainedMoves; //已约束传送指令
    list<Expression*> frozenMoves;      //已冻结传送指令
    list<Expression*> worklistMoves;    //待合并的传送指令
    list<Expression*> activeMoves;      //活跃的传送指令
    vector<vector<int>> adjMatrix;      //邻接矩阵
    vector<list<int>> adjList;          //邻接表
    vector<int> degrees;                //度
    vector<int> alias;                  //别名
    vector<int> color;                  //颜色
    vector<NodeStatus> status;          //顶点状态
    vector<list<Expression*>> useList;  //使用该变量的指令表
    vector<list<Expression*>> defList;  //定义该变量的指令表
    vector<list<Expression*>> moveList; //与该变量有关的传送指令表


    void ColorAlgorithmMain();          //图染色主函数
    void AddEdge(int x,int y);          //建图添加边
    void livelyAnalyz();                //活性分析
    void InitColorAlgorithm();          //初始化
    void DecrementDegree(int m);        //顶点度数减1
    bool MoveRelated(int n);            //n是否是传送相关的
    list<Expression*>& NodeMoves(int n);//与n相关的传送指令(未冻结的)
    list<int>& Adjacent(int n);         //n的邻点集
    void Simplify();                    //简化
    void Coalesce();                    //合并
    int GetAlias(int x);                //获取别名(由合并产生)
    void AddWorklist(int u);            //加入工作表
    bool TestPrecoloredCombine(int u/*precolored*/,int v); //测试预着色节点相关传送指令是否可以合并
    bool TestConservative(int u,int v); //测试传送指令是否可以保守合并
    void Combine(int u,int v);          //合并
    void EnableMoves(int m);            //将m相关的传送指令设为待合并的
    void FreezeMoves(int u);            //将u相关的传送指令冻结
    void FreezeAction();                //冻结
    void SelectSpill();                 //选择高度数节点溢出
    void AssignColors();                //分配颜色
    void RewriteProgram();              //重写程序,对于有真实溢出的情况
    void InsertExprForWrite(Expression* e,int v);   //插入栈内存写入
    void InsertExprForRead(Expression* e,int v);    //插入栈内存读取
    int GenTempVariable();              //获取一个新临时变量的id

    //程序流处理及优化
    void InitializeVectorSpace();       //初始化
    void InitFunEnv();                  //函数入口形参处理
    int insert();                       //添加一个int变量到栈中
    void frameFree();                   //释放栈的最后一个空间
    void SaveReg();                     //call语句出保存调用者保存的寄存器
    void OptimizeFlow();                //优化程序流(常数传播)
    void OptimizeDead();                //死代码消除
    void OptimizeLoadStore();           //优化
    void genFlow();                     //生成程序流

    //生成代码
    string opstring(int op);            //获得op对应的运算符
    string opinstruct(int op);          //获得op对应的RiscV指令
    void OutputArithRIMul(int reg1,int reg2,unsigned imm);  //处理ArithRI指令的RiscV输出(将乘以2的幂改为左移)
    void GenCode();                     //生成tigger代码
    void GenRiscv64();                  //生成RiscV64代码
    void GenRiscv32();                  //生成Riscv32代码
    void checkReturn();                 //检查函数退出前是否有返回指令
};
\end{lstlisting}
\subsection{程序流生成}
Parser分析到函数体结尾end func时会生成一个Empty类型语句表示函数体的结束.

程序流分析过程对Expression对象的nexts属性和prevs属性赋值,使其分别指向e的所有前驱和所有后继.

除Goto,If类,Return,Empty语句外,所有语句在vector<Expression*> exprs中的后继都是其程序流中的后继(称为默认后继).

对于Goto语句,其后继为Goto 所指向标号对应的Label语句;

对于If类语句,其后继为默认后继以及所指向标号对应的Label语句;

对于Return语句,其后继为表示函数体结束的Empty语句.

\subsection{return语句检查}
如果函数结尾处的Empty语句有不是return语句的前驱,则说明程序控制流到了函数末尾,会给出警告;

并会自动在函数结尾处添加一条return 0;
\subsection{活性分析}
以语句为基本块进行自下而上的活性分析.使用队列进行宽度优先搜索,递推式为:
$$e.in = e.use\cup (e.out - e.def)$$
$$e.out = \cup_{x\in e.nexts} (x.in)$$
如果进行上述计算后e.in和e.out有所改变,则将e的前驱加入队列.

迭代直到队列为空.

\subsection{死代码消除}
此处处理的死代码分为两种:

(1)$e.def \bigcap\left( \bigcup_{x\in e.nexts}x.in \right)== \Phi$ 即该语句定义的变量在这条语句的所有
后继中都不是入口活跃的.

(2)不可达语句,即在活性分析时未处理的语句.

对于第(1)情行,未定义变量的语句和控制流跳转类语句为例外排除.

\subsection{常数传播}
每个Expression语句对象都有一个constant属性,他是一个map表,从变量id映射到该处(出口处)的变量常数值. 此表只会储存此处为常数值的变量.

按顺序遍历所有语句,对于每个语句,计算一个mp(map表)
$$ mp = \bigcap_{x \in e.prevs}x.constant $$
即mp为e的所有前驱的constant表中项的交集,也即对于所有前驱语句都具有相同常数值的变量.

对于非跳转类或访存类语句,如果$ x\in mp \forall x\in e.use $成立,也即所有被x使用的变量在此处均为常数,则可说明此语句定义的变量也为常数. 调用calcarith函数计算此算术运算.并将该语句的类型改为MoveRI(即将直接数赋值给变量的语句)

对于上面公式不成立的语句, 以及跳转类和访存类语句, 令
$$ mp = mp - e.def $$
即此处被定义的变量标记为不是常数.

最后令 $  e.constant = mp $ 记录此语句处的常量表

\subsection{访存优化}
死代码消除和常数传播的优化是在寄存器分配之前就完成的, 而访存优化主要是优化对局部变量的访存指令.考虑这两种情况: (1)当寄存器不够用时,图染色算法将局部变量溢出至栈帧, 然后RewriteProgram过程会为每次对该局部变量的读取增加FrameLoad指令, 对修改增加FrameStore指令.(2)连续的call语句时,调用者保存的寄存器会被连续存取但却不会改变.

以上两种情况可能产生一些冗余的访存指令.

此处使用两种规则优化:

(1) 设本条语句FrameLoad n x.若当前寄存器x在上一句FrameLoad n x后未改变,且上条语句和本条语句之间没有跳转类语句,标号或者数组写入语句,则当前FrameLoad语句可被优化.

(2) 设本条语句FrameStore n x.若当前寄存器x在上一句FrameLoad n x后未改变,且上条语句和本条语句之间没有跳转类语句,标号或者数组写入语句,则当前FrameStore语句和之前的FrameLoad语句都可被优化. 

举例:

(1)
\begin{lstlisting}
//此处设a保存在栈帧中
c = a + b;
d = a + c;
e = c + d;
\end{lstlisting}

优化前的tigger代码:
\begin{lstlisting}
load  0 a0
a1 = a0 + a1
load  0 a0
a1 = a0 + a1
a1 = a1 + a1
\end{lstlisting}
优化后的tigger代码
\begin{lstlisting}
load  0 a0
a1 = a0 + a1
a1 = a0 + a1
a1 = a1 + a1
\end{lstlisting}

(2)
\begin{lstlisting}
b = a + 2;
d = func(1);
d = func(2);
return b;
\end{lstlisting}
优化前的tigger代码:
\begin{lstlisting}
a1 = a0 + 2
a0 = 1
store a1 0
call func
load 0 a1
a0 = 2
store a1 0
call func
load 0 a1
a0 = a1
return
\end{lstlisting}
优化后的tigger代码
\begin{lstlisting}
a1 = a0 + 2
a0 = 1
store a1 0
call func
a0 = 2
call func
load 0 a1
a0 = a1
return
\end{lstlisting}
\subsection{寄存器分配}
使用图着色算法进行寄存器分配.\footnote{寄存器分配的算法参考了《现代编译原理-C语言描述（修订版）》第11章}

利用活性分析的结果构造冲突图,兼用邻接表和邻接矩阵表示冲突图.

图染色有四种操作:
\begin{enumerate}[1.]
\item 简化:对于度数小于k的传送无关的点,将其从图中删除并放入栈中.
\item 合并:对于一条传送指令,对其关联的两个点在保守规则下合并.
\item 冻结:冻结一条传送指令,将他当作非传送指令.
\item 溢出:将图中度数最大的点放入栈中,并从图中删除.
\end{enumerate}
操作按1.2.3.4的优先级进行,直到图中不再有点.

将栈中元素依次弹出,并为其分配颜色,如果无颜色可用,则将该顶点真实溢出.

若有真实溢出发生,则重写程序,为溢出的变量分配栈空间,加入load语句和store语句来读取和写回,并创建临时变量进行运算.
\subsection{其他说明}
Tigger不再创建符号表,因为其中所有变量名称的作用域都是全局,所以直接由词法分析器为其分配一个id(>27).\
全局变量和栈数组不分配寄存器,直接存到内存中.
\subsection{预着色节点的处理}
Tigger有28个寄存器,给其确定id为0-27,以作为预着色节点,在活性分析中与其他变量处于同等地位. 在图着色时也可与与其相关的传送节点合并.但两个不同色的预着色节点无法合并.
\subsection{形参的处理}
函数参数及返回值需要预着色,函数体的开头会创建临时变量,使用传送指令将预着色节点传送到临时变量作为形参,以避免形参长期占用a开头寄存器.
\subsection{调用函数}
该部分tigger.y代码:
\begin{lstlisting}
Expression:
| ...
| PARAM Symbol                                {AnalyzInstance.currentFunc().CallParam($2,1);}
| PARAM INTEGER                                 {AnalyzInstance.currentFunc().CallParam($2,0);}
| Symbol '=' CALL FUNCTION                    {AnalyzInstance.currentFunc().CallFunc($1,$4);}
| ...
\end{lstlisting}
该部分analyz.cpp代码:
\begin{lstlisting}
void Func::CallParam(int v,int t)
{
    if(t == 1)
    {
    new Expression(MoveRR,{(int)(a0)+paramToCallWithCount},{v},{});
    }
    else
    {
    new Expression(MoveRI,{(int)(a0)+paramToCallWithCount},{},{v});
    }
    paramToCallWithCount++;
}
void Func::CallFunc(int v,string f)
{
    vector<int> paramvec;
    paramvec.push_back(int(a0));
    for(int i = 1; i<paramToCallWithCount;i ++)
    {
        paramvec.push_back((int)(a0) + i);
    }
    new Expression(Call,{(int)(a0)},paramvec,{},f);
    new Expression(MoveRR,{v},{(int)(a0)},{});
    paramToCallWithCount = 0;
}
\end{lstlisting}

Func类设置了一个计数器计数当前传入参数的个数. 计数器初始化为0, 每扫描并处理一个Param语句, 将计数器值加一.

对于`Param x`语句,将其处理为 `a0 = x`(对应Expression的类型为MoveRR), 其中0可能为0-7,是传参计数器的当前值.

由Eeyore的构成,在Param语句和对应的Call语句之间不会有其他会改变参数寄存器值的语句,而Call语句的right属性会被设置成{a0,a1,..,at},其中t为参数的个数-1;

因此活性分析的结果会阻止Param语句和Call语句之间的其他无关变量被分配为a0-at寄存器.

\subsection{合并预着色点相关传送节点的例子}
MiniC代码
\begin{lstlisting}
int v0;
v0 = getint();
int v1;
v1 = func(v0);
int v2;
v2 = putint(v1+1);
return v2;
\end{lstlisting}
tigger代码
\begin{lstlisting}
call getint
call func
a0 = a0 + 1
call putint
return
\end{lstlisting}
riscv64代码
\begin{lstlisting}
main:
	add	sp,sp,-16
	sd	ra,8(sp)
	call	getint
	call	func
	addiw	a0,a0,1
	call	putint
	ld	ra,8(sp)
	addi	sp,sp,16
	jr	ra
	.size	main, .-main
\end{lstlisting}
变量大量合并,只用了a0,没有一条move指令.
\section{Risc-v64/32}
本编译器生成Risc-v64/32的代码写在tigger部分之中, 未单独编写.

Tigger中设置了全局变量target指示需要生成的代码类型.

Func类中的函数GenCode(), GenRiscv64(), GenRiscv32() 三个函数分别生成对应函数的Tigger, Riscv64 和 Riscv32 代码, Analyz类中的GenGlobalTigger() 和GenGlobal()函数 分别生成Tigger和Riscv32/64的全局变量信息.

tigger程序运行时接受一个参数, 如提供 -m64 参数,Riscv-64 代码,如提供 -m32 参数,则输出Riscv-32代码. 如未提供参数或提供了其他参数, 则默认生成Tigger代码.

由于Riscv不支持寄存器乘以直接数的指令, 因此在Tigger中规定了寄存器乘以直接数的指令中的直接数必须为2的幂以便转换为左移指令. 在Riscv代码输出过程中,Func类有OutputArithRIMulI(int reg1,int reg2,int op)函数来处理这种指令, 将其变为左移指令输出.

此外, 依照MiniC-Checker平台的要求, tigger文件夹中提供了三个利用管道实现的脚本tiggerC,riscv64C和riscv32C,他们接受miniC代码,输出对应代码.
\section{hcc}
整个编译器已整合为hcc

从 https://github.com/vangohao/hcc 获取源码

在repo根目录运行``make''

运行 ``./hcc qsort.c'' or ``./hcc qsort''来将 qsort.c 编译为RISCV64汇编代码 qsort.s

运行 ``./hcc -m32 qsort.c'' or ``./hcc -m32 qsort''来将 qsort.c 编译为RISCV32汇编代码 qsort.s

hcc 是一个脚本,实际是调用eeyore程序和tigger程序实现, 在eeyore有错误时会提前终止程序.

hcc脚本内容如下:
\begin{lstlisting}
#!/bin/bash

Help(){
	echo "Please input a source file name."
	echo "For example:"
	echo "./hcc qsort.c" 
	echo "or"
	echo "./hcc qsort"
	echo "or"
	echo "./hcc -m32 qsort.c"
}

if [[ $# -gt 0 ]] && [[ $1 != "--help" ]]
then
	if [ $1 == "-m32" ]
	then
		TC="-m32"
		if [[ $# -gt 1 ]]
		then
			F=${2%.c}
		else
			Help
			exit
		fi
	else
		if [[ $# -gt 1 ]] && [[ $2 == "-m32" ]]
		then
			TC="-m32"
		else
			TC="-m64"
		fi
		F=${1%.c}
	fi
	if [ -f "$F.c" ]
	then
		./tigger/eeyore < "$F.c" > "$F.ee"
		EC=$?
		if [ ${EC} -eq 0 ]  
		then
			./tigger/tigger ${TC} < "$F.ee" > "$F.s"
			EC=$?
			if [ ${EC} -eq 0 ]
			then
				rm -f "$F.ee"
				if [[ ${TC} == "-m32" ]]
				then
					echo "RISC-V32 code has sucessfully written to $F.s"
				else
					echo "RISC-V64 code has sucessfully written to $F.s"
				fi
			else
				rm -f "$F.ee" "$F.s"
				echo "tigger return exit code ${EC}: hcc stoped."
			fi
				
		else
			rm -f "$F.ee"
			echo "eeyore return exit code ${EC}: hcc stoped."
		fi
	else
		echo "$F.c not exists."
	fi
else
	Help
fi
\end{lstlisting}
\end{document}
